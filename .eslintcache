[{"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamCard/StreamCard.jsx":"1","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/twitch.js":"2","/Users/diego/Documents/react/QaplaStreamersDashboard/src/App.js":"3","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamersSignin/StreamersSignin.jsx":"4","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PubSubTest/PubSubTest.jsx":"5","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js":"6","/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js":"7","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx":"8","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ContainedButton/ContainedButton.jsx":"9","/Users/diego/Documents/react/QaplaStreamersDashboard/src/index.js":"10","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx":"11","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/auth.js":"12","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerTextInput/StreamerTextInput.jsx":"13","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/firebase.js":"14","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx":"15"},{"size":7042,"mtime":1619895178605,"results":"16","hashOfConfig":"17"},{"size":11590,"mtime":1620168426096,"results":"18","hashOfConfig":"17"},{"size":159,"mtime":1614731664613,"results":"19","hashOfConfig":"17"},{"size":5688,"mtime":1620858322894,"results":"20","hashOfConfig":"17"},{"size":7426,"mtime":1620942046153,"results":"21","hashOfConfig":"17"},{"size":11058,"mtime":1620941385183,"results":"22","hashOfConfig":"17"},{"size":3283,"mtime":1620858329706,"results":"23","hashOfConfig":"17"},{"size":4141,"mtime":1614731664833,"results":"24","hashOfConfig":"17"},{"size":767,"mtime":1614731664822,"results":"25","hashOfConfig":"17"},{"size":500,"mtime":1614731664837,"results":"26","hashOfConfig":"17"},{"size":7031,"mtime":1620941403723,"results":"27","hashOfConfig":"17"},{"size":4003,"mtime":1619894681084,"results":"28","hashOfConfig":"17"},{"size":1760,"mtime":1614731664834,"results":"29","hashOfConfig":"17"},{"size":1369,"mtime":1620942652946,"results":"30","hashOfConfig":"17"},{"size":20044,"mtime":1620942986483,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"gt9ikh",{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamCard/StreamCard.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/twitch.js",["65"],"import {\n    giveStreamExperienceForRewardRedeemed,\n    updateStreamerProfile,\n    saveStreamerTwitchCustomReward,\n    removeStreamerTwitchCustomReward,\n    saveCustomRewardRedemption,\n    updateCustomRewardRedemptionStatus,\n    getUserByTwitchId,\n    isUserRegisteredToStream\n} from './database';\nimport { TWITCH_CLIENT_ID, TWITCH_SECRET_ID } from '../utilities/Constants';\n\nlet webSocket;\n\n/**\n * Establish a connection between the dashboard and the twitch using web sockets\n * @param {string} uid User identifier\n * @param {string} accessToken Twitch access token\n * @param {array} topics Array of strings with the topics to listen\n * @param {stirng} rewardId Id of the qapla custom reward\n * @param {function} onInvalidRefreshToken Callback for invalid twitch refresh token\n */\nexport function connect(streamId, uid, accessToken, topics, rewardId, onInvalidRefreshToken) {\n    let pingInterval = 1000 * 60;\n    let reconnectInterval = 1000 * 3;\n    let pingHandle;\n\n    webSocket = new WebSocket('wss://pubsub-edge.twitch.tv');\n\n    webSocket.onopen = (error) => {\n        ping();\n        pingHandle = setInterval(ping, pingInterval);\n        listen(topics, accessToken, uid, onInvalidRefreshToken);\n    };\n\n    webSocket.onerror = (error) => {\n        console.log(error);\n    };\n\n    webSocket.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        console.log(message);\n        if (message.data) {\n            const reward = JSON.parse(message.data.message);\n            if (reward.type === 'reward-redeemed') {\n                const redemptionData = reward.data.redemption;\n                handleCustomRewardRedemption(streamId, rewardId, redemptionData);\n            }\n\n            if (message.type === 'RECONNECT') {\n                setTimeout(() => connect(streamId, uid, accessToken, topics, onInvalidRefreshToken), reconnectInterval);\n            }\n        }\n    };\n\n    webSocket.onclose = () => {\n        clearInterval(pingHandle);\n    };\n}\n\nexport function closeConnection() {\n    webSocket.close();\n}\n\n/**\n * Fulfill any redemption of the Qapla custom reward redeemed by Qapla users who are subscribed\n * to the given stream and cancel any redemption of the Qapla custom reward for no users or users\n * not subscribed to the event. Ignore any other custom reward redemption\n * @param {string} streamId Streamer Twitch id\n * @param {string} rewardId Qapla Custom Reward Id\n * @param {object} redemptionData Redemption twitch object\n */\nexport async function handleCustomRewardRedemption(streamId, rewardId, redemptionData) {\n    console.log(redemptionData);\n    if (redemptionData.reward.id === rewardId) {\n        console.log('Qapla Custom reward redeemed', redemptionData.user.id);\n        const user = await getUserByTwitchId(redemptionData.user.id);\n        if (user) {\n            console.log('Redeemed by qapla user:', user.id);\n            const isUserParticipantOfStream = await isUserRegisteredToStream(user.id, streamId);\n            if (isUserParticipantOfStream) {\n                console.log(`User ${user.id} is subscribed to stream`);\n                await saveCustomRewardRedemption(user.id, user.photoUrl, redemptionData.user.id, redemptionData.user.display_name, streamId, redemptionData.id, redemptionData.reward.id, redemptionData.status);\n                console.log('Giving experience to user:', user.id);\n                // updateCustomRewardRedemptionStatus(streamId, redemptionData.id, status);\n                giveStreamExperienceForRewardRedeemed(user.id, user.qaplaLevel, user.userName, 25);\n\n                return;\n            } else {\n                console.log(`User ${user.id} is NOT subscribed to stream`);\n            }\n        }\n    }\n}\n\n/**\n * Send a LISTEN request to twitch to tell them what topics we want to listen\n * @param {array} topics Array of strings with the topics to listen\n * @param {string} accessToken Twitch access token\n * @param {string} uid User identifier\n * @param {function} onInvalidRefreshToken Callback for invalid twitch refresh token\n */\nexport async function listen(topics, accessToken, uid, onInvalidRefreshToken) {\n    const twitchAccessTokenStatus = await getTwitchAccessTokenStatus(accessToken);\n    if (twitchAccessTokenStatus === 401) {\n        await refreshTwitchToken(uid, accessToken, onInvalidRefreshToken);\n        return await listen(topics, accessToken, uid, onInvalidRefreshToken);\n    }\n\n    const message = {\n        type: 'LISTEN',\n        nonce: nonce(15),\n        data: {\n            topics: topics,\n            auth_token: accessToken\n        }\n    };\n\n    setTimeout(() => webSocket.send(JSON.stringify(message)), 1250);\n}\n\n/**\n * Send a ping to twitch\n */\nfunction ping() {\n    const message = {\n        type: 'PING'\n    };\n\n    if (webSocket.readyState === WebSocket.OPEN) {\n        webSocket.send(JSON.stringify(message));\n    }\n}\n\n/**\n * Return a random string of the specified length\n * @param {string} length Size of the string\n */\nfunction nonce(length) {\n    var text = \"\";\n    var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    for (var i = 0; i < length; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n\n    return text;\n}\n\n/**\n * Create a custom reward in the user´s twitch\n * @param {string} uid User identifier\n * @param {string} twitchId Twitch identifier\n * @param {string} accessToken Twitch access token\n * @param {string} title Title of the reward\n * @param {number} cost Cost for redeem the reward\n * @param {function} onInvalidRefreshToken Callback for invalid twitch refresh token\n */\nexport async function createCustomReward(uid, twitchId, accessToken, title, cost, onInvalidRefreshToken) {\n    try {\n        const twitchAccessTokenStatus = await getTwitchAccessTokenStatus(accessToken);\n        if (twitchAccessTokenStatus === 401) {\n            await refreshTwitchToken(uid, accessToken, onInvalidRefreshToken);\n            return createCustomReward(uid, twitchId, accessToken, title, cost, onInvalidRefreshToken);\n        }\n\n        let res = await fetch(`https://api.twitch.tv/helix/channel_points/custom_rewards?broadcaster_id=${twitchId}`, {\n            method: 'POST',\n            headers: {\n                'Client-Id': TWITCH_CLIENT_ID,\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json; charset=utf-8'\n            },\n            body: JSON.stringify({\n                title,\n                cost,\n                is_max_per_user_per_stream_enabled: false,\n                // max_per_user_per_stream: 2,\n                is_max_per_stream_enabled: false,\n                is_enabled: true\n            })\n        });\n\n        const response = await res.json();\n        if (response.data && response.data[0]) {\n            saveStreamerTwitchCustomReward(uid, response.data[0].id, response.data[0].title, response.data[0].cost);\n\n            return response.data[0];\n        }\n    } catch (e) {\n        console.log('Error: ', e);\n    }\n}\n\n/**\n * Delete a custom reward in the user´s twitch\n * @param {string} uid User identifier\n * @param {string} twitchId Twitch identifier\n * @param {string} accessToken Twitch access token\n * @param {string} rewardId Id of the reward to delete\n * @param {function} onInvalidRefreshToken Callback for invalid twitch refresh token\n */\nexport async function deleteCustomReward(uid, twitchId, accessToken, rewardId, onInvalidRefreshToken) {\n    try {\n        const twitchAccessTokenStatus = await getTwitchAccessTokenStatus(accessToken);\n        if (twitchAccessTokenStatus === 401) {\n            await refreshTwitchToken(uid, accessToken, onInvalidRefreshToken);\n            return await deleteCustomReward(uid, twitchId, accessToken, rewardId, onInvalidRefreshToken);\n        }\n\n        let response = await fetch(`https://api.twitch.tv/helix/channel_points/custom_rewards?broadcaster_id=${twitchId}&id=${rewardId}`, {\n            method: 'DELETE',\n            headers: {\n                'Client-Id': TWITCH_CLIENT_ID,\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json; charset=utf-8'\n            }\n        });\n\n        if (response.status === 204 ) {\n            removeStreamerTwitchCustomReward(uid, response.data[0].id, response.data[0].title, response.data[0].cost);\n        }\n\n        return response.status;\n    } catch (e) {\n        console.log('Error: ', e);\n    }\n}\n\n/**\n * Update the status of the given redemption\n * @param {string} uid Streamer user identifier\n * @param {string} redemptionId Redemption twitch identifier\n * @param {strint} streamerId Streamer Twitch id\n * @param {string} accessToken Twitch access token\n * @param {string} rewardId Qapla custom reward identifier\n * @param {string} status Status to assign (FULFILLED or CANCELED)\n * @param {function} onInvalidRefreshToken Callback for invalid tokens\n */\nexport async function updateRedemptionStatus(uid, redemptionId, streamerId, accessToken, rewardId, status, onInvalidRefreshToken) {\n    console.log('Fulfill Redemption:', status, redemptionId);\n    const twitchAccessTokenStatus = await getTwitchAccessTokenStatus(accessToken);\n    if (twitchAccessTokenStatus === 401) {\n        await refreshTwitchToken(uid, accessToken, onInvalidRefreshToken);\n        return await updateRedemptionStatus(uid, redemptionId, streamerId, accessToken, rewardId, status, onInvalidRefreshToken);\n    }\n\n    console.log('Fulfill Redemption:', status, redemptionId);\n\n    let response = await fetch('https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions?' +\n    `&broadcaster_id=${streamerId}` +\n    `&reward_id=${rewardId}` +\n    `&id=${redemptionId}`, {\n        method: 'PATCH',\n        headers: {\n            'Content-Type': 'application/json',\n            headers: {\n                'Client-Id': TWITCH_CLIENT_ID,\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json; charset=utf-8'\n            },\n            body: JSON.stringify({\n                status\n            })\n        }\n    });\n\n    response = await response.json();\n\n    console.log(response);\n\n    return response.data[0].status;\n}\n\n/**\n * Try to refresh the token if it can´t then call the onInvalidRefreshToken callback\n * @param {string} uid User identifier\n * @param {string} accessToken Twitch acces token\n * @param {function} onInvalidRefreshToken Callback for invalid twitch refresh token\n */\nexport async function refreshTwitchToken(uid, accessToken, onInvalidRefreshToken) {\n    let algo = await fetch('https://id.twitch.tv/oauth2/token?grant_type=refresh_token' +\n    `&refresh_token=${accessToken}` +\n    `&client_id=${TWITCH_CLIENT_ID}` +\n    `&client_secret=${TWITCH_SECRET_ID}`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'\n        }\n    });\n\n    const result = (await algo.json());\n    if (result.status === 400) {\n        await onInvalidRefreshToken();\n    } else {\n        await updateStreamerProfile(uid, { twitchAccessToken: result.access_token, refreshToken: result.refresh_token });\n\n        return result;\n    }\n}\n\n/**\n * Check if a twitch access token is valid, 200 if it is valid\n * @param {string} twitchAccessToken Twitch access token\n */\nexport async function getTwitchAccessTokenStatus(twitchAccessToken) {\n    const response = await fetch('https://id.twitch.tv/oauth2/validate', {\n        headers: {\n            Authorization: `OAuth ${twitchAccessToken}`\n        }\n    });\n\n    return response.status;\n}",["66","67"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/App.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamersSignin/StreamersSignin.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PubSubTest/PubSubTest.jsx",["68"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ContainedButton/ContainedButton.jsx",[],["69","70"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/index.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/auth.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerTextInput/StreamerTextInput.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/firebase.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx",[],{"ruleId":"71","severity":1,"message":"72","line":7,"column":5,"nodeType":"73","messageId":"74","endLine":7,"endColumn":39},{"ruleId":"75","replacedBy":"76"},{"ruleId":"77","replacedBy":"78"},{"ruleId":"71","severity":1,"message":"79","line":124,"column":11,"nodeType":"73","messageId":"74","endLine":124,"endColumn":23},{"ruleId":"75","replacedBy":"80"},{"ruleId":"77","replacedBy":"81"},"no-unused-vars","'updateCustomRewardRedemptionStatus' is defined but never used.","Identifier","unusedVar","no-native-reassign",["82"],"no-negated-in-lhs",["83"],"'deleteReward' is assigned a value but never used.",["82"],["83"],"no-global-assign","no-unsafe-negation"]
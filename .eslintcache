[{"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js":"1","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/CheersBitsRecordDialog/CheersBitsRecordDialog.jsx":"2","/Users/diego/Documents/react/QaplaStreamersDashboard/src/utilities/i18n.js":"3","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx":"4","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/Settings/Settings.jsx":"5","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/CasthQutDialog/CasthQutDialog.jsx":"6","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaStreamDialogs/EventConfirmStartDialog.jsx":"7","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ModalQoinsDrops/ModalQoinsDrops.jsx":"8","/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js":"9","/Users/diego/Documents/react/QaplaStreamersDashboard/src/App.js":"10","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx":"11","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BackButton/BackButton.jsx":"12","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx":"13","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BioEditorTextArea/BioEditorTextArea.jsx":"14","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/streamQapla.js":"15"},{"size":38145,"mtime":1663302383868,"results":"16","hashOfConfig":"17"},{"size":20857,"mtime":1663283542064,"results":"18","hashOfConfig":"17"},{"size":870,"mtime":1650310830028,"results":"19","hashOfConfig":"17"},{"size":20005,"mtime":1663283542065,"results":"20","hashOfConfig":"17"},{"size":835,"mtime":1642711713952,"results":"21","hashOfConfig":"17"},{"size":2668,"mtime":1663283542063,"results":"22","hashOfConfig":"17"},{"size":3414,"mtime":1663016164629,"results":"23","hashOfConfig":"17"},{"size":6609,"mtime":1663016164627,"results":"24","hashOfConfig":"17"},{"size":4861,"mtime":1663424018951,"results":"25","hashOfConfig":"17"},{"size":226,"mtime":1659480227124,"results":"26","hashOfConfig":"17"},{"size":22970,"mtime":1661972327647,"results":"27","hashOfConfig":"17"},{"size":1083,"mtime":1650310829993,"results":"28","hashOfConfig":"17"},{"size":14683,"mtime":1663016164638,"results":"29","hashOfConfig":"17"},{"size":7574,"mtime":1663302383860,"results":"30","hashOfConfig":"17"},{"size":5435,"mtime":1663016164640,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},"rfo3np",{"filePath":"36","messages":"37","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js",["64","65"],"import { database, databaseServerValue } from './firebase';\n\nconst gamesRef = database.ref('/GamesResources');\nconst InvitationCodeRef = database.ref('/InvitationCode');\nconst userStreamersRef = database.ref('/UserStreamer');\nconst streamsApprovalRef = database.ref('/StreamsApproval');\nconst streamersEventsDataRef = database.ref('/StreamersEventsData');\nconst streamsRef = database.ref('/eventosEspeciales').child('eventsData');\nconst streamersHistoryEventsDataRef = database.ref('/StreamersHistoryEventsData');\nconst streamParticipantsRef = database.ref('/EventParticipants');\nconst userRef = database.ref('/Users');\nconst redeemedCustomRewardsRef = database.ref('/RedeemedCustomRewards');\nconst activeCustomRewardsRef = database.ref('/ActiveCustomRewards');\nconst redemptionsListsRef = database.ref('/RedemptionsLists');\nconst streamersDonationsRef = database.ref('/StreamersDonations');\nconst premiumEventsSubscriptionRef = database.ref('/PremiumEventsSubscription');\nconst streamersDonationsTestRef = database.ref('/StreamersDonationsTest');\nconst paymentsToStreamersHistory = database.ref('/PaymentsToStreamersHistory');\nconst streamerLinksRef = database.ref('/StreamerLinks');\nconst streamsPackagesRef = database.ref('/StreamsPackages');\nconst streamersSubscriptionsDetailsRef = database.ref('/StreamersSubscriptionsDetails');\nconst streamersPublicProfilesRef = database.ref('/StreamersPublicProfiles');\nconst subscriptionPurchaseDetailsRef = database.ref('/SubscriptionPurchaseDetails');\nconst tagsRef = database.ref('/Tags');\nconst streamerAlertsSettingsRef = database.ref('/StreamerAlertsSettings');\nconst streamerCustomMediaForCheers = database.ref('/StreamerCustomMediaForCheers');\nconst qoinsToBitForStreamersRef = database.ref('/QoinsToBitForStreamers');\nconst qlanesRef = database.ref('/Qlanes');\nconst qreatorsCodesRef = database.ref('/QreatorsCodes');\nconst qaplaChallengeRef = database.ref('/QaplaChallenge');\nconst qStoreRef = database.ref('/QStore');\nconst userStreamerPublicDataRef = database.ref('/UserStreamerPublicData');\nconst streamersInteractionsRewardsRef = database.ref('/StreamersInteractionsRewards');\nconst streamerReactionTestMediaRef = database.ref('StreamerReactionTestMedia');\nconst giphyTextRequestsRef = database.ref('/GiphyTextRequests');\nconst streamersDeepLinksRef = database.ref('/StreamersDeepLinks');\nconst dashboardStreamersVisitsCounterRef = database.ref('/DashboardStreamersVisitsCounter');\nconst uberduckRequestsRef = database.ref('/UberduckRequests');\nconst streamerCashOutRef = database.ref('/StreamersCashOut');\n\n/**\n * Load all the games ordered by platform from GamesResources\n * database node\n */\nexport async function loadQaplaGames() {\n    return (await gamesRef.once('value')).val();\n}\n\nexport function loadStreamerProfile(uid, dataHandler) {\n    userStreamersRef.child(uid).on('value', (streamerData) => {\n        if (streamerData.exists()) {\n            dataHandler(streamerData.val());\n        }\n    });\n}\n\n/**\n  * Check if the invitation code exists\n  * @param {string} invitationCode Random invitation code\n  */\n export async function invitationCodeExists(invitationCode) {\n    if (invitationCode) {\n        return (await InvitationCodeRef.child(invitationCode).once('value')).exists();\n    }\n\n    return false;\n}\n\n/**\n * Get the invitationCode node information (users with free trials code have special fields)\n * @param {string} invitationCode Random invitation code\n */\nexport async function getInvitationCodeParams(invitationCode) {\n    return await InvitationCodeRef.child(invitationCode).once('value');\n}\n\n/**\n * Removes the given invitation code from database\n * @param {string} invitationCode Invitation code\n */\nexport async function removeInvitationCode(invitationCode) {\n    return await InvitationCodeRef.child(invitationCode).remove();\n}\n\n/**\n * Return true if the streamer id exists\n * @param {string} uid Streamer Identifier\n */\nexport async function streamerProfileExists(uid) {\n    return (await userStreamersRef.child(uid).once('value')).exists();\n}\n\n/**\n * Creates the profile for the streamer\n * @param {string} uid User Identifier\n * @param {object} userData Data to save\n */\nexport async function createStreamerProfile(uid, userData) {\n    if (userData.isNewUser) {\n        delete userData.isNewUser;\n        if (!userData.email) {\n            userData.email = '';\n        }\n    }\n\n    return await userStreamersRef.child(uid).update(userData);\n}\n\n/**\n * Update the streamer private and public (if exists) profile with the given data\n * @param {string} uid User identifier\n * @param {object} userData Data to update\n */\nexport async function updateStreamerProfile(uid, userData) {\n    await userStreamersRef.child(uid).update(userData);\n\n    if (userData.displayName && userData.photoUrl) {\n        const broadcasterType = userData.broadcasterType ? userData.broadcasterType : {};\n        await updateUserStreamerPublicData(uid, {\n            displayName: userData.displayName,\n            photoUrl: userData.photoUrl,\n            displayNameLowerCase: userData.displayName.toLowerCase(),\n            broadcasterType\n        });\n\n        const publicProfile = await streamersPublicProfilesRef.child(uid).once('value');\n        if (publicProfile.exists()) {\n            await streamersPublicProfilesRef.child(uid).update({\n                displayName: userData.displayName,\n                displayNameLowerCase: userData.displayName.toLowerCase(),\n                photoUrl: userData.photoUrl,\n                broadcasterType\n            });\n        }\n    }\n}\n\n/**\n * Update the data on the User Streamer Public Data node\n * @param {string} uid User identifier\n * @param {object} streamerData Data to update\n */\nexport async function updateUserStreamerPublicData(uid, streamerData) {\n    await userStreamerPublicDataRef.child(uid).update(streamerData);\n}\n\n/**\n * Gets the uid of the streamer using theit twitchId\n * @param {string} twitchId Twitch id of the streamer\n */\nexport async function getStreamerUidWithTwitchId(twitchId) {\n    const streamerSnapshot = await userStreamersRef.orderByChild('id').equalTo(twitchId).once('value');\n    let uid = '';\n    streamerSnapshot.forEach((streamer) => {\n        uid = streamer.key;\n    });\n\n    return uid;\n}\n\n/**\n * Save on the streamer profile and in the active custom rewards node a new custom reward created with the\n * dashboard\n * @param {string} uid User identifier\n * @param {string} rewardName String name to identify on the database\n * @param {string} rewardId New custom reward identifier\n * @param {string} title Title of the new reward\n * @param {number} cost Cost (in bits) of the new reward\n * @param {string} streamId Id of the stream event\n */\nexport async function saveStreamTwitchCustomReward(uid, rewardName, rewardId, streamId, webhookId) {\n    const webhookIdKey = `${rewardName}WebhookId`;\n\n    // Timestamp will be overwritten because we used it as a \"last reward created\" record\n    await activeCustomRewardsRef.child(streamId).update({ streamerUid: uid, [rewardName]: rewardId, timestamp: (new Date()).getTime(), [webhookIdKey]: webhookId });\n}\n\n/**\n * Updates an Active Custom Reward node with given rewardsData object\n * @param {string} streamId Stream identifier\n * @param {object} rewardsData Data to update\n */\nexport async function updateActiveCustomReward(streamId, rewardsData) {\n    return await activeCustomRewardsRef.child(streamId).update(rewardsData);\n}\n\n/**\n * Gets the information about the given active event\n * @param {string} streamId Stream identifier\n */\nexport async function checkActiveCustomReward(streamId) {\n    return await activeCustomRewardsRef.child(streamId).once('value');\n}\n\n/**\n * Listen to the value of qoinsEnabled flag\n * @param {string} streamId Stream identifier\n * @param {function} callback Function to handle listener results\n */\nexport function listenToQoinsEnabled(streamId, callback) {\n    activeCustomRewardsRef.child(streamId).child('qoinsEnabled').on('value', callback);\n}\n\nexport function removeQoinsEnabledListener(streamId) {\n    activeCustomRewardsRef.child(streamId).child('qoinsEnabled').off('value');\n}\n\n/**\n * Create a stream request in the nodes StreamersEvents and StreamsApproval\n * @param {string} uid User identifier\n * @param {object} streamerData Streamer data object\n * @param {string} game Selected game for the stream\n * @param {string} date Date in format DD-MM-YYYY\n * @param {string} hour Hour in format hh:mm\n * @param {string} streamType One of 'exp' or 'tournament'\n * @param {timestamp} timestamp Timestamp based on the given date and hour\n * @param {object} optionalData Customizable data for events\n * @param {number} createdAt timestamp of when the request was created\n * @param {string} stringDate Temporary field just to detect a bug\n */\nexport async function createNewStreamRequest(uid, streamerData, game, date, hour, streamType, timestamp, optionalData, createdAt, stringDate) {\n    const event = await streamersEventsDataRef.child(uid).push({\n        date,\n        hour,\n        game,\n        status: 1,\n        streamType,\n        timestamp,\n        optionalData,\n        createdAt,\n        stringDate\n    });\n\n    await premiumEventsSubscriptionRef.child(uid).child(event.key).set({\n        approved: false,\n        timestamp\n    });\n\n    return await streamsApprovalRef.child(event.key).set({\n        date,\n        hour,\n        game,\n        idStreamer: uid,\n        streamerName: streamerData.displayName,\n        streamType,\n        timestamp,\n        streamerChannelLink: 'https://twitch.tv/' + streamerData.login,\n        streamerPhoto: streamerData.photoUrl,\n        optionalData,\n        createdAt,\n        stringDate\n    });\n}\n\nexport async function getUserDisplayName(uid) {\n    return await userStreamersRef.child(uid).child('displayName').once('value');\n}\n\n/**\n * Streams\n */\n\n/**\n * Load all the strams of StreamersEventsData based on their value on the status flag\n * @param {string} uid User identifier\n * @param {number} status Value of the status to load\n */\nexport async function loadStreamsByStatus(uid, status) {\n    return await streamersEventsDataRef.child(uid).orderByChild('status').equalTo(status).once('value');\n}\n\n/**\n * Load all the strams of StreamersEventsData based on the given statues\n * @param {string} uid User identifier\n * @param {number} statusStart Status where the query starts\n * @param {number} statusEnd Status where the query end\n */\n export async function loadStreamsByStatusRange(uid, statusStart, statusEnd) {\n    return await streamersEventsDataRef.child(uid).orderByChild('status').startAt(statusStart).endAt(statusEnd).once('value');\n}\n\n/**\n * Removes a stream request of the database\n * @param {string} uid User identifier\n * @param {string} streamId Identifier of the stream to remove\n */\nexport async function cancelStreamRequest(uid, streamId) {\n    await streamersEventsDataRef.child(uid).child(streamId).remove();\n    await streamsApprovalRef.child(streamId).remove();\n    userStreamersRef.child(uid).child('subscriptionDetails').child('streamsRequested').transaction((numberOfRequests) => {\n        if (numberOfRequests) {\n            return numberOfRequests - 1;\n        }\n    });\n}\n\n/**\n * Update the status in the StreamersEventsData node\n * @param {string} uid User identifier\n * @param {string} streamId Streamer identifier\n * @param {number} status New status value\n */\nexport async function updateStreamStatus(uid, streamId, status) {\n    return await streamersEventsDataRef.child(uid).child(streamId).update({ status });\n}\n\n/**\n * Save a copy of the event in the StreamersHistoryEventsData and remove the event from eventosEspeciales/eventsData\n * @param {string} uid User identifier\n * @param {string} streamId Stream identifier\n */\nexport async function removeStreamFromEventsData(uid, streamId) {\n    const streamData = await streamsRef.child(streamId).once('value');\n\n    if (streamData.exists()) {\n        // Save a copy in the streamer event history\n        await streamersHistoryEventsDataRef.child(uid).child(streamId).update(streamData.val());\n        // Admin copy while we test if everything is working\n        database.ref('EventsDataAdmin').child(streamId).update(streamData.val());\n    }\n\n    return await streamsRef.child(streamId).remove();\n}\n\n/**\n * Returns the value of the participantsNumber node of the given stream\n * @param {string} streamId Stream unique identifier\n */\nexport async function getStreamParticipantsNumber(streamId) {\n    return await streamsRef.child(streamId).child('participantsNumber').once('value');\n}\n\n/**\n * Returns the value of the title node of the given stream\n * @param {string} streamId Stream unique identifier\n */\nexport async function getStreamTitle(streamId) {\n    return await streamsRef.child(streamId).child('title').once('value');\n}\n\n/**\n * Returns the value of the timestamp node of the given stream\n * @param {string} streamId Stream unique identifier\n */\nexport async function getStreamTimestamp(streamId) {\n    return await streamsRef.child(streamId).child('timestamp').once('value');\n}\n\n/**\n * Returns all the data of the given stream\n * @param {string} streamId Stream unique identifier\n */\nexport async function loadApprovedStreamTimeStamp(streamId) {\n    return await streamsRef.child(streamId).child('timestamp').once('value');\n}\n\n/**\n * Update the date, hour and timestamps of the given stream\n * @param {string} uid User identifier\n * @param {string} streamId Streamer identifier\n * @param {string} dateUTC Date UTC in format DD-MM-YYYY\n * @param {string} hourUTC Hour UTC in format HH:MM\n * @param {string} date Local Date in format DD-MM-YYYY\n * @param {string} hour Local hour in format HH:MM\n * @param {number} timestamp Timestamp of the dates\n */\nexport async function updateStreamDate(uid, streamId, dateUTC, hourUTC, date, hour, timestamp) {\n    await streamsRef.child(streamId).update({\n        dateUTC,\n        hourUTC,\n        tiempoLimite: date,\n        hour,\n        timestamp\n    });\n\n    const lastTimestamp = await userStreamersRef.child(uid).child('lastStreamTs').once('value');\n    if (!lastTimestamp.exists() || (lastTimestamp.exists() && lastTimestamp.val() < timestamp)) {\n        userStreamersRef.child(uid).update({ lastStreamTs: timestamp });\n    }\n\n    return await streamersEventsDataRef.child(uid).child(streamId).update({\n        date: dateUTC,\n        hour: hourUTC,\n        timestamp\n    });\n}\n\n/**\n * Returns the customRewardsMultipliers object of the given stream\n * @param {string} streamId Stream identifier\n */\nexport async function getStreamCustomRewardsMultipliers(streamId) {\n    return await streamsRef.child(streamId).child('customRewardsMultipliers').once('value');\n}\n\n/**\n * Stream Participants\n */\n\n/**\n * Returns the value of the participantsNumber node of the given past stream\n * @param {string} uid User identifier\n * @param {string} streamId Stream unique identifier\n */\nexport async function getPastStreamParticipantsNumber(uid, streamId) {\n    return await streamersHistoryEventsDataRef.child(uid).child(streamId).child('participantsNumber').once('value');\n}\n\n/**\n * Returns the list of participants of the given stream\n * @param {string} streamId Stream unique identifier\n */\nexport async function getStreamParticipantsList(streamId) {\n    return await streamParticipantsRef.child(streamId).once('value');\n}\n\n/**\n * Returns the value of the participantsNumber node of the given past stream\n * @param {string} uid User identifier\n * @param {string} streamId Stream unique identifier\n */\nexport async function getPastStreamTitle(uid, streamId) {\n    return await streamersHistoryEventsDataRef.child(uid).child(streamId).child('title').once('value');\n}\n\n/**\n * @deprecated\n * @param {string} streamerId Id of the streamer\n * @param {string} streamId Stream identifier in our database\n */\nexport async function getCustomRewardId(streamerId ,streamId) {\n    return await (await userStreamersRef.child(streamerId).child('customRewards').child(streamId).child('rewardId').once('value')).val();\n}\n\n/**\n * Returns the snapshor of the custom reward for the given event\n * @param {string} streamerId Id of the streamer\n * @param {string} streamId Stream identifier in our database\n */\nexport async function getStreamCustomReward(streamerId ,streamId) {\n    return await userStreamersRef.child(streamerId).child('customRewards').child(streamId).once('value');\n}\n\n/**\n * Update the status of the given custom redemption\n * @param {string} streamId Stream identifier in our database\n * @param {string} redemptionId Id of the twitch redemption\n * @param {string} status Status of the redemption\n */\nexport async function updateCustomRewardRedemptionStatus(streamId, redemptionId, status) {\n    await redeemedCustomRewardsRef.child(streamId).child(redemptionId).update({ status });\n}\n\n/**\n * Set a listener for the redeemedCustomRewardsRef/streamId node\n * @param {string} streamId Stream identifier in our database\n * @param {function} callback Handler of the returned data\n */\nexport async function listenCustomRewardRedemptions(streamId, callback) {\n    redeemedCustomRewardsRef.child(streamId).on('value', callback);\n}\n\n/**\n * App users\n */\n\n/**\n * Return a user profile object (node Users in our database) based on their twitchId or null\n * if it does not exist\n * @param {string} twitchId Twitch id\n */\nexport async function getUserByTwitchId(twitchId) {\n    const users = await userRef.orderByChild('twitchId').equalTo(twitchId).once('value');\n    let user = null;\n    users.forEach((qaplaUser) => {\n        user = { ...qaplaUser.val(), id: qaplaUser.key };\n    });\n\n    return user;\n}\n\n/**\n * Remove a stream from te ActiveCustomRewards node\n * @param {string} streamId Stream identifier\n */\nexport async function removeActiveCustomRewardFromList(streamId) {\n    return await activeCustomRewardsRef.child(streamId).remove();\n}\n\nexport async function setStreamInRedemptionsLists(streamId) {\n    const date = new Date();\n    await redemptionsListsRef.child(streamId).set({ timestamp: date.getTime() });\n}\n\nexport async function addListToStreamRedemptionList(streamId, type, list) {\n    await redemptionsListsRef.child(streamId).update({ [type]: list });\n}\n\n/**\n * Listener to check if the streamer is online\n * @param {string} streamerUid Uid of the streamer\n * @param {function} callback Handler of the results\n */\nexport function listenToUserStreamingStatus(streamerUid, callback) {\n    userStreamersRef.child(streamerUid).child('isStreaming').on('value', callback);\n}\n\n/**\n * Streamers Donations and Streamers Donations Tests\n */\n\n/**\n * Listener to get the last x cheers added to the StreamersDonations\n * @param {string} streamerUid Uid of the streamer\n * @param {function} callback Handler of the results\n */\nexport function listenForLastStreamerCheers(streamerUid, limit = 10, callback) {\n    streamersDonationsRef.child(streamerUid).limitToLast(limit).on('value', callback);\n}\n\n/**\n * Listener to get every unread streamer cheer added to the StreamersDonations\n * @param {string} streamerUid Uid of the streamer\n * @param {function} callback Handler of the results\n */\nexport function listenForUnreadStreamerCheers(streamerUid, callback) {\n    streamersDonationsRef.child(streamerUid).orderByChild('read').equalTo(false).on('child_added', callback);\n}\n\n/**\n * Remove listener from the Streamers Donation node\n * @param {string} streamerUid Uid of the streamer\n */\n export function removeListenerForLastStreamerCheers(streamerUid) {\n    streamersDonationsRef.child(streamerUid).off('value');\n}\n\n/**\n * Remove listener from the Streamers Donation node\n * @param {string} streamerUid Uid of the streamer\n */\nexport function removeListenerForUnreadStreamerCheers(streamerUid) {\n    streamersDonationsRef.child(streamerUid).orderByChild('read').equalTo(false).off('child_added');\n}\n\n/**\n * Write a fake cheer on the test cheers node\n * @param {string} streamerUid Streamer unique identifier\n * @param {string} completeMessage Message to show if the operation is succesfuly completed\n * @param {string} errorMessage Message to show if the write operation fails\n */\nexport async function writeTestCheer(streamerUid, completeMessage, errorMessage) {\n    const testMediaArrayLength = await streamerReactionTestMediaRef.child('length').once('value');\n    const index = Math.floor(Math.random() * testMediaArrayLength.val());\n    const media = (await streamerReactionTestMediaRef.child('media').child(index).once('value')).val();\n\n    streamersDonationsTestRef.child(streamerUid).push({\n        media,\n        amountQoins: 0,\n        message: 'Test',\n        timestamp: (new Date()).getTime(),\n        uid: '',\n        read: false,\n        twitchUserName: 'QAPLA',\n        emojiRain: {\n            emojis: ['ðŸ‘‹']\n        },\n        media: {\n            id: 'Iz0eDDbIrrItMCp2lO',\n            type: 'gif',\n            url: 'https://media2.giphy.com/media/bGCwmLDnwL25kCg3FV/giphy.gif?cid=4a0959dab7zzbi4dj9xiwv1dvfbut8y76yk7b08sglwcdltp&rid=giphy.gif&ct=g',\n            height: 480,\n            width: 480\n        },\n        messageExtraData: {\n            voiceAPIName: 'pt-BR-Standard-B',\n            giphyText: {\n                url: 'https://text.media.giphy.com/v1/media/giphy.gif?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJrZXkiOiJwcm9kLTIwMjAtMDQtMjIiLCJzdHlsZSI6Im1lbWUiLCJ0ZXh0IjoiQnVlbmFzIGJ1ZW5hcyEiLCJpYXQiOjE2NjE0NDk1NTR9.iDZZaFNXfW7TISZM-eS3ZF76X2RFrp6k5H_BL5BIzU0&cid=025a3d845a80faa3d6f2c679f74e7958b157c9e17aac766e&dynamic_style=meme&rid=giphy.gif&ct=t',\n                height: 300,\n                width: 600\n            }\n        },\n        userName: 'QAPLA',\n        photoURL: ''\n    }, (error) => {\n        if (error) {\n            if (errorMessage) {\n                alert(errorMessage);\n            }\n        } else {\n            if (completeMessage) {\n                alert(completeMessage);\n            }\n        }\n    });\n}\n\n/**\n * Listener for the unread test cheers\n * @param {string} streamerUid Stremer identifier\n * @param {function} callback Function called for every cheer\n */\nexport function listenForTestCheers(streamerUid, callback) {\n    streamersDonationsTestRef.child(streamerUid).orderByChild('read').equalTo(false).on('child_added', callback)\n}\n\n/**\n * Removes the given test donation\n * @param {string} streamerUid Streamer identifier\n * @param {string} donationId Donation identifier\n */\nexport function removeTestDonation(streamerUid, donationId) {\n    streamersDonationsTestRef.child(streamerUid).child(donationId).remove();\n}\n\n/**\n * Mark as read the given donation\n * @param {string} streamerUid Uid of the streamer who receive the donation\n * @param {string} donationId Id of the donation\n */\nexport async function markDonationAsRead(streamerUid, donationId) {\n    return await streamersDonationsRef.child(streamerUid).child(donationId).update({ read: true });\n}\n\n/**\n * Mark as unread and repeating the given donation\n * @param {string} streamerUid Uid of the streamer who receive the donation\n * @param {string} donationId Id of the donation\n */\nexport async function markDonationAsUnreadToRepeat(streamerUid, donationId) {\n    return await streamersDonationsRef.child(streamerUid).child(donationId).update({ read: false, repeating: true });\n}\n\n/**\n * Set to true the isOverlayActive flag of the streamer\n * @param {string} streamerUid Streamer identifier\n */\nexport async function markOverlayAsActive(streamerUid) {\n    return await userStreamerPublicDataRef.child(streamerUid).child('isOverlayActive').set(true);\n}\n\n/**\n * Set to onDisconnect listener for the isOverlayActive flag\n * @param {string} streamerUid Streamer identifier\n */\nexport function onLiveDonationsDisconnect(streamerUid) {\n    userStreamerPublicDataRef.child(streamerUid).child('isOverlayActive').onDisconnect().set(false);\n}\n\n/**\n * Streamers Subscriptions\n */\n\n/**\n * Save the subscription information of the given user\n * @param {string} uid User identifier\n * @param {string} stripeCustomerId Customer Id given by stripe\n * @param {number} periodStart Timestamp of period start (in milliseconds)\n * @param {number} periodEnd Timestamp of period end (in milliseconds)\n */\nexport async function saveSubscriptionInformation(uid, stripeCustomerId, periodStart, periodEnd) {\n    userStreamersRef.child(uid).update({\n        freeTrial: null,\n        premium: true,\n        currentPeriod: {\n            startDate: periodStart,\n            endDate: periodEnd\n        },\n        stripeCustomerId\n    });\n}\n\n/**\n * Add/overwrite the subscriptionDetails information on the given user\n * @param {string} uid User identifier\n * @param {object} subscriptionDetails Subscription details\n */\nexport async function updateSubscriptionDetails(uid, subscriptionDetails) {\n    await userStreamersRef.child(uid).update({ subscriptionDetails });\n}\n/**\n * Get the payments received by the streamer in the giving period\n * @param {string} streamerUid Uid of the streamer\n * @param {number} startTimestamp Lower limit for the time query\n * @param {number} endTimestamp Superior limit for the time query\n */\nexport async function getPeriodStreamerPayments(streamerUid, startTimestamp, endTimestamp) {\n    return await paymentsToStreamersHistory.child(streamerUid).orderByChild('timestamp').startAt(startTimestamp).endAt(endTimestamp).once('value');\n}\n\n/**\n* Streamers Links\n */\n\n/**\n * Saves a link information for the streamer public profile\n * @param {string} streamerUid Uid of the streamer\n * @param {Array} link Array of URLs and titles to save [ { title: 'Twitch', url: 'https://twitch.tv/mr_yuboto' } ]\n */\n export async function saveStreamerLinks(streamerUid, links) {\n    await streamerLinksRef.child(streamerUid).update(links);\n}\n\n/**\n * Get all the links of the given streamer\n * @param {string} streamerUid Uid of the streamer\n */\nexport async function getStreamerLinks(streamerUid) {\n    return await streamerLinksRef.child(streamerUid).once('value');\n}\n\n/**\n * Qoin Reward Redemption counter\n */\n\n/**\n * Returns the value of the qoinsRedemptionsCounter of the given stream\n * @param {string} streamId Streamer identifier\n */\nexport async function getStreamRedemptionCounter(streamId) {\n    return await streamsRef.child(streamId).child('qoinsRedemptionsCounter').once('value');\n}\n\n/**\n * Gets all the packages on the Streams Packages node\n */\nexport async function getStreamsPackages() {\n    return await streamsPackagesRef.once('value');\n}\n\n/**\n * Gets all the subscriptions informations in the Streamers Subscriptions Details node\n */\nexport async function getSubscriptionsDetails() {\n    return await streamersSubscriptionsDetailsRef.once('value');\n}\n\n/**\n * Add a child on the boughtStreams node in the user profile so the user can have more streams independently\n * of the streams that their subscription already included\n * @param {string} streamerUid User identifier\n * @param {number} boughtStreams Number of streams bought by the streamer\n * @param {timestamp} expirationTimestamp Timestamp of the maxim date to use the streams\n */\nexport async function addBoughtStreamsToStreamer(streamerUid, boughtStreams, expirationTimestamp) {\n    await userStreamersRef.child(streamerUid).child('boughtStreams').push({\n        boughtStreams,\n        expirationTimestamp\n    });\n}\n\n/**\n * Add one to the streamsRequested node of the given streamer in their subscriptionDetails\n * (streamsRequested in this node is the counter of events for their included on their subscription streams)\n * @param {string} streamerUid Streamer user identifier\n */\nexport async function addToStreamsRequestedOnSubscriptionDetails(streamerUid) {\n    userStreamersRef.child(streamerUid).child('subscriptionDetails').child('streamsRequested').transaction((numberOfRequests) => {\n        if (!numberOfRequests) {\n            return 1;\n        }\n\n        return numberOfRequests + 1;\n    });\n}\n\n/**\n * Add one to the streamsRequested node of the given streamer in their boughtStreams/{package}\n * (streamsRequested in this node is the counter of events for their package that the user bought)\n * @param {string} streamerUid Streamer user identifier\n */\nexport async function addToStreamsRequestedOnStreamsPackage(streamerUid, packageId) {\n    userStreamersRef.child(streamerUid).child('boughtStreams').child(packageId).child('streamsRequested').transaction((numberOfRequests) => {\n        if (!numberOfRequests) {\n            return 1;\n        }\n\n        return numberOfRequests + 1;\n    });\n}\n\n/**\n * Remove a package of the boughtStreams node in the user profile\n * @param {string} streamerUid Streamer user identifier\n * @param {string} packageId Package identifier\n */\nexport async function removeStreamPackageOfStreamer(streamerUid, packageId) {\n    userStreamersRef.child(streamerUid).child('boughtStreams').child(packageId).remove();\n}\n\n/**\n * Streamers Public Profiles\n */\n\n/**\n * Listen to the specified streamer profile\n * @param {string} uid User identifier\n * @param {function} callback Handler for firebase snapshot\n */\nexport function listenStreamerPublicProfile(uid, callback) {\n    return streamersPublicProfilesRef.child(uid).on('value', callback);\n}\n\n/**\n * Updates the specified streamer profile with the given data\n * @param {string} uid User identifier\n * @param {object} dataToUpdate Data to update on profile\n */\nexport async function updateStreamerPublicProfile(uid, dataToUpdate) {\n    return await streamersPublicProfilesRef.child(uid).update(dataToUpdate);\n}\n\n/**\n * Returns true if the user has a public profile created\n * @param {string} uid User identifier\n */\nexport async function userHasPublicProfile(uid) {\n    return (await streamersPublicProfilesRef.child(uid).once('value')).exists();\n}\n\n/**\n * Subscription Purchase Details\n */\n\n/**\n * Get the details of the given subscription of the specified user\n * @param {string} uid User identifier\n * @param {string} subscriptionId Subscription stripe identifier\n */\nexport async function getSubscriptionPurchaseDetails(uid, subscriptionId) {\n    return await subscriptionPurchaseDetailsRef.child(uid).child(subscriptionId).once('value');\n}\n\n/**\n * Save all the tags on te Tags node\n * @param {object} tags Object of tags in format { tag1: true, tag2: true }\n */\nexport async function saveTags(tags) {\n    await tagsRef.update(tags);\n}\n\n/**\n * Streamer Alerts Settings\n */\n\n/**\n * Set a setting on the Streamer Alert Settings\n * @param {string} uid User identifier\n * @param {string} settingKey Setting to set\n * @param {*} value Value to set\n */\nexport async function setAlertSetting(uid, settingKey, value) {\n    await streamerAlertsSettingsRef.child(uid).child(settingKey).set(value);\n}\n\n/**\n * Get the alerts settings of the given streamer\n * @param {string} uid User identifier\n */\n export async function getStreamerAlertsSettings(uid) {\n    return await streamerAlertsSettingsRef.child(uid).once('value');\n}\n\n/**\n * Listen the alerts settings of the given streamer (useful in the LiveDonations component)\n * @param {string} uid User identifier\n * @param {function} callback Function to handle the response of the listener\n */\nexport function listenToStreamerAlertsSettings(uid, callback) {\n    return streamerAlertsSettingsRef.child(uid).on('value', callback);\n}\n\n/**\n * QoinsToBitForStreamers\n */\n\n/**\n * Get the value of Qoins in bit for the given type of user\n * @param {string} type Type of user (one of premium or freeUser)\n */\nexport async function getStreamerValueOfQoins(type) {\n    return qoinsToBitForStreamersRef.child(type).once('value');\n}\n\n/**\n * Qlanes\n */\n\n/**\n * Returns true if the user has a Qlan\n * @param {string} uid User identifier\n */\nexport async function streamerHasQlan(uid) {\n    return (await qlanesRef.child(uid).once('value')).exists();\n}\n\n/**\n * Creates a Qlan for the given user\n * @param {string} uid User identifier\n * @param {string} code Qreator code\n * @param {string} name Name of the Qlan\n * @param {string} image Image url\n */\nexport async function createQlan(uid, code, name, image) {\n    await qreatorsCodesRef.child(uid).update({ code, codeLowerCase: code.toLowerCase() });\n    return await qlanesRef.child(uid).update({ name, image });\n}\n\n/**\n * Gets the Qreator code of the given user\n * @param {string} uid User identifier\n */\nexport async function getQreatorCode(uid) {\n    return await qreatorsCodesRef.child(uid).child('code').once('value');\n}\n\n/**\n * Returns the id of the Qlan based on the Qreator code\n * @param {string} qreatorCode Unique code to join a Qlan\n */\nexport async function getQlanIdWithQreatorCode(qreatorCode) {\n    let id = '';\n\n    const codes = await qreatorsCodesRef.orderByChild('code').equalTo(qreatorCode).once('value');\n\n    /**\n     * We know this query will return a maximum of one code, however firebase returns an object of objects\n     * so we need to go through it to get the code\n     */\n    codes.forEach((code) => id = code.key);\n\n    return id;\n}\n\n/**\n * Gets the category of the Qapla Challenge in which the user is participating\n * @param {string} streamerUid Streamer identifier\n */\nexport async function getStreamerChallengeCategory(streamerUid) {\n    return await qaplaChallengeRef.child(streamerUid).child('category').once('value');\n}\n\n////////////////////////\n// Q Store\n////////////////////////\n\n/**\n * Gets all the items in the Q-Store\n */\nexport async function getQStoreItems() {\n    return await qStoreRef.once('value');\n}\n\n////////////////////////\n// Referral codes\n////////////////////////\n\n/**\n * Add two events to a streamer who referred other streamer\n * @param {string} uid User identifier of the user to receive the rewards\n * @param {string} referredDisplayName Display name from the user who used the referral code\n * @param {number} endDate Timestamp in ms for the end date of the events added\n */\nexport async function giveReferrerRewardsToStreamer(uid, referredDisplayName, endDate) {\n    await userStreamersRef.child(uid).child('subscriptionDetails').child('streamsIncluded').set(databaseServerValue.increment(2));\n    await userStreamersRef.child(uid).child('subscriptionDetails').child('redemptionsPerStream').set(40);\n\n    await userStreamersRef.child(uid).update({\n        premium: true\n    });\n    await updateUserStreamerPublicData(uid, {\n        premium: true\n    });\n\n    const referrerCurrentPeriod = await userStreamersRef.child(uid).child('currentPeriod').once('value');\n    const today = new Date();\n\n    if (!referrerCurrentPeriod.exists() || (today.getTime() >= referrerCurrentPeriod.val().endDate)) {\n        await userStreamersRef.child(uid).child('currentPeriod').child('endDate').set(endDate);\n        if (!referrerCurrentPeriod.exists() || !referrerCurrentPeriod.val().startDate) {\n            await userStreamersRef.child(uid).child('currentPeriod').child('startDate').set(today.getTime());\n        }\n    }\n}\n\n////////////////////////\n// Channel Point Interactions\n////////////////////////\n\nexport async function saveInteractionsRewardData(uid, rewardId, webhookId) {\n    await streamersInteractionsRewardsRef.child(uid).update({ rewardId, webhookId })\n}\n\n/**\n * Get the interactions reward data of the given user\n * @param {string} uid User identifier\n */\nexport async function getInteractionsRewardData(uid) {\n    return await streamersInteractionsRewardsRef.child(uid).once('value');\n}\n\n////////////////////////\n// Giphy Text\n////////////////////////\n\n/**\n * Saves on database the given array of Giphy Texts\n * @param {string} uid User identifier\n * @param {array} data Array of Giphy Text gifs\n */\n export async function saveGiphyText(uid, data) {\n    return giphyTextRequestsRef.child(uid).set(data);\n}\n\n////////////////////////\n// Streamer Deep Links\n////////////////////////\n\n/**\n * Save the deep link of the streamer on database\n * @param {string} uid User identifier\n * @param {string} url Deep link to save\n */\nexport async function saveStreamerDeepLink(uid, url) {\n    return await streamersDeepLinksRef.child(uid).set(url);\n}\n\n/**\n * Gets the streamer deep link\n * @param {string} uid User identifier\n */\nexport async function getStreamerDeepLink(uid) {\n    return await streamersDeepLinksRef.child(uid).once('value');\n}\n\n////////////////////////\n// Visits counter\n////////////////////////\n\n/**\n * Set the number of visits the user has done to the dashboard (used to show optional profile-link onboarding every 3 times the\n * user enters the dashboard)\n * @param {string} uid User identifier\n * @param {number} count Number of visits to set\n */\nexport async function setVisitsCounter(uid, count) {\n    return await dashboardStreamersVisitsCounterRef.child(uid).set(count);\n}\n\n/**\n * Gets the number of visits of the user\n * @param {string} uid User identifier\n */\nexport async function getNumberOfVisits(uid) {\n    return await dashboardStreamersVisitsCounterRef.child(uid).once('value');\n}\n// Uberduck requests\n////////////////////////\n\n/**\n * Listen for the given donation Uberduck request\n * @param {string} donationId Donation identifier\n * @param {function} callback Handler for listener results\n */\nexport async function listenForUberduckAudio(donationId, callback) {\n    uberduckRequestsRef.child(donationId).on('value', callback);\n}\n\n/**\n * Remove the listene from the given donation Uberduck request\n * @param {string} donationId Donation identifier\n */\nexport async function removeListenerForUberduckAudio(donationId) {\n    uberduckRequestsRef.child(donationId).off('value');\n}\n////////////////////////\n// Streamer Cash Out\n////////////////////////\n\n/**\n * Saves the request of cash out for the given streamer\n * @param {string} uid User identifier\n * @param {number} amountQoins Amount of Qoins to remove from the streamer balance\n * @param {number} amountBits Amount of bits to deliver to the streamer\n */\nexport async function saveStreamerCashOutRequest(uid, amountQoins, amountBits) {\n    const date = new Date();\n\n    const qoinsRemoved = await userStreamersRef.child(uid).child('qoinsBalance').transaction((qoinsBalance) => {\n        return qoinsBalance - amountQoins;\n    });\n\n    if (qoinsRemoved.committed) {\n        return await streamerCashOutRef.child(uid).push({\n            amountQoins,\n            amountBits,\n            delivered: false,\n            timestamp: date.getTime()\n        });\n    }\n}",["66","67"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/CheersBitsRecordDialog/CheersBitsRecordDialog.jsx",["68","69"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/utilities/i18n.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/Settings/Settings.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/CasthQutDialog/CasthQutDialog.jsx",["70"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaStreamDialogs/EventConfirmStartDialog.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ModalQoinsDrops/ModalQoinsDrops.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js",["71"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/App.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx",["72"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BackButton/BackButton.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BioEditorTextArea/BioEditorTextArea.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/streamQapla.js",[],{"ruleId":"73","severity":1,"message":"74","line":26,"column":7,"nodeType":"75","messageId":"76","endLine":26,"endColumn":35},{"ruleId":"77","severity":1,"message":"78","line":568,"column":9,"nodeType":"79","messageId":"80","endLine":568,"endColumn":14},{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","replacedBy":"84"},{"ruleId":"73","severity":1,"message":"85","line":273,"column":21,"nodeType":"75","messageId":"76","endLine":273,"endColumn":31},{"ruleId":"86","severity":1,"message":"87","line":453,"column":8,"nodeType":"88","endLine":453,"endColumn":14,"suggestions":"89"},{"ruleId":"86","severity":1,"message":"90","line":33,"column":8,"nodeType":"88","endLine":33,"endColumn":20,"suggestions":"91"},{"ruleId":"73","severity":1,"message":"92","line":31,"column":10,"nodeType":"75","messageId":"76","endLine":31,"endColumn":14},{"ruleId":"73","severity":1,"message":"93","line":13,"column":5,"nodeType":"75","messageId":"76","endLine":13,"endColumn":11},"no-unused-vars","'streamerCustomMediaForCheers' is assigned a value but never used.","Identifier","unusedVar","no-dupe-keys","Duplicate key 'media'.","ObjectExpression","unexpected","no-native-reassign",["94"],"no-negated-in-lhs",["95"],"'setBalance' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setPendingMessages'. Either include it or remove the dependency array. If 'setPendingMessages' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["96"],"React Hook useEffect has a missing dependency: 'bits'. Either include it or remove the dependency array.",["97"],"'auth' is defined but never used.","'Hidden' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"98","fix":"99"},{"desc":"100","fix":"101"},"Update the dependencies array to be: [setPendingMessages, user]",{"range":"102","text":"103"},"Update the dependencies array to be: [amountBits, bits]",{"range":"104","text":"105"},[17494,17500],"[setPendingMessages, user]",[1065,1077],"[amountBits, bits]"]
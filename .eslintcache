[{"/Users/diego/Documents/react/QaplaStreamersDashboard/src/utilities/Constants.js":"1","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PubSubTest/PubSubTest.jsx":"2","/Users/diego/Documents/react/QaplaStreamersDashboard/src/index.js":"3","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamersSignin/StreamersSignin.jsx":"4","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/InviteCode/InviteCode.jsx":"5","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx":"6","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js":"7","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LanguageSelect/LanguageSelect.jsx":"8","/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js":"9","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx":"10","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PlanPicker/PlanPicker.jsx":"11","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerOnBoarding/StreamerOnBoarding.jsx":"12","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/twitch.js":"13","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSelect/StreamerSelect.jsx":"14","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaTabs/QaplaTab.jsx":"15","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerTextInput/StreamerTextInput.jsx":"16","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LanguageHandler/LanguageHandler.jsx":"17","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx":"18","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/functions.js":"19","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaTabs/QaplaTabs.jsx":"20","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BackButton/BackButton.jsx":"21","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EventSent/EventSent.jsx":"22","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/firebase.js":"23","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/NewStreamDetailsDialog/NewStreamDetailsDialog.jsx":"24","/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/discord.js":"25","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/Settings/Settings.jsx":"26","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ContainedButton/ContainedButton.jsx":"27","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/NewStream/NewStream.jsx":"28","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerDashboardContainer/StreamerDashboardContainer.jsx":"29","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LiveDonations/LiveDonations.jsx":"30","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamCard/StreamCard.jsx":"31"},{"size":5256,"mtime":1629325751890,"results":"32","hashOfConfig":"33"},{"size":24779,"mtime":1628549555386,"results":"34","hashOfConfig":"33"},{"size":527,"mtime":1627071614512,"results":"35","hashOfConfig":"33"},{"size":6114,"mtime":1628030063605,"results":"36","hashOfConfig":"33"},{"size":3325,"mtime":1614731664825,"results":"37","hashOfConfig":"33"},{"size":20379,"mtime":1627092065255,"results":"38","hashOfConfig":"33"},{"size":20704,"mtime":1629582946508,"results":"39","hashOfConfig":"33"},{"size":1596,"mtime":1628030063594,"results":"40","hashOfConfig":"33"},{"size":3959,"mtime":1629587315314,"results":"41","hashOfConfig":"33"},{"size":8857,"mtime":1629645741255,"results":"42","hashOfConfig":"33"},{"size":2841,"mtime":1629645640830,"results":"43","hashOfConfig":"33"},{"size":2975,"mtime":1614731664830,"results":"44","hashOfConfig":"33"},{"size":21501,"mtime":1628549555388,"results":"45","hashOfConfig":"33"},{"size":1361,"mtime":1628030063604,"results":"46","hashOfConfig":"33"},{"size":695,"mtime":1627071614509,"results":"47","hashOfConfig":"33"},{"size":1730,"mtime":1627071614512,"results":"48","hashOfConfig":"33"},{"size":629,"mtime":1628030063593,"results":"49","hashOfConfig":"33"},{"size":13534,"mtime":1629645611459,"results":"50","hashOfConfig":"33"},{"size":1967,"mtime":1628030063608,"results":"51","hashOfConfig":"33"},{"size":291,"mtime":1627071614509,"results":"52","hashOfConfig":"33"},{"size":1011,"mtime":1614731664821,"results":"53","hashOfConfig":"33"},{"size":3579,"mtime":1614731664824,"results":"54","hashOfConfig":"33"},{"size":1369,"mtime":1625590018867,"results":"55","hashOfConfig":"33"},{"size":3205,"mtime":1625936949693,"results":"56","hashOfConfig":"33"},{"size":1113,"mtime":1625936949695,"results":"57","hashOfConfig":"33"},{"size":808,"mtime":1627095167711,"results":"58","hashOfConfig":"33"},{"size":921,"mtime":1625936949691,"results":"59","hashOfConfig":"33"},{"size":21260,"mtime":1628030063595,"results":"60","hashOfConfig":"33"},{"size":2410,"mtime":1628030063602,"results":"61","hashOfConfig":"33"},{"size":5064,"mtime":1627071614507,"results":"62","hashOfConfig":"33"},{"size":9152,"mtime":1628030063602,"results":"63","hashOfConfig":"33"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},"rfo3np",{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"70"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"81","messages":"82","errorCount":1,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"70"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"112"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"73"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"123","messages":"124","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"125","messages":"126","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"127","messages":"128","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"129","messages":"130","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"131","messages":"132","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/diego/Documents/react/QaplaStreamersDashboard/src/utilities/Constants.js",[],["133","134"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PubSubTest/PubSubTest.jsx",["135"],"import React, { useState, useEffect } from 'react';\nimport { useParams, Prompt } from 'react-router';\nimport {\n    makeStyles,\n    withStyles,\n    TableCell,\n    Grid,\n    TableContainer,\n    Table,\n    TableHead,\n    TableRow,\n    TableBody,\n    Avatar,\n    CircularProgress\n} from '@material-ui/core';\nimport { useTranslation } from 'react-i18next';\n\nimport { ReactComponent as ProfileIcon } from './../../assets/ProfileIcon.svg';\nimport { ReactComponent as ConnectedIcon } from './../../assets/ganado.svg';\nimport { ReactComponent as DisconnectedIcon } from './../../assets/perdido.svg';\n\nimport { connect, createCustomReward, deleteCustomReward, closeConnection, getAllRewardRedemptions, enableCustomReward } from '../../services/twitch';\nimport { signInWithTwitch } from '../../services/auth';\nimport ContainedButton from '../ContainedButton/ContainedButton';\nimport {\n    updateStreamerProfile,\n    listenCustomRewardRedemptions,\n    getStreamTimestamp,\n    getStreamCustomReward,\n    getUserByTwitchId,\n    addQoinsToUser,\n    addInfoToEventParticipants,\n    saveUserStreamReward,\n    giveStreamExperienceForRewardRedeemed,\n    saveCustomRewardRedemption,\n    markAsClosedStreamerTwitchCustomReward,\n    removeActiveCustomRewardFromList,\n    getOpenCustomRewards,\n    setStreamInRedemptionsLists,\n    addListToStreamRedemptionList,\n    saveStreamerTwitchCustomReward,\n    getStreamUserRedemptions\n} from '../../services/database';\nimport StreamerDashboardContainer from '../StreamerDashboardContainer/StreamerDashboardContainer';\nimport { XQ, QOINS, TWITCH_PUBSUB_UNCONNECTED, TWITCH_PUBSUB_CONNECTED, TWITCH_PUBSUB_CONNECTION_LOST, HOUR_IN_MILISECONDS } from '../../utilities/Constants';\n\n\n\nconst useStyles = makeStyles((theme) => ({\n    tableHead: {\n        fontSize: '16px !important',\n        color: '#808191 !important',\n        fontWeight: 'bold'\n    },\n    tableRow: {\n        backgroundColor: 'rgba(20, 24, 51, .5)'\n    },\n    tableRowOdd: {\n        backgroundColor: 'transparent'\n    },\n    firstCell: {\n        borderRadius: '1rem 0 0 1rem',\n    },\n    lastCell: {\n        borderRadius: '0 1rem 1rem 0',\n    },\n    avatar: {\n        width: theme.spacing(3),\n        height: theme.spacing(3),\n        marginLeft: '.25rem'\n    },\n    tableContainer: {\n        marginTop: 16\n    },\n    secondaryButton: {\n        backgroundColor: '#00FFDD !important',\n        marginTop: 16,\n        color: '#000'\n    }\n}));\n\nconst TableCellStyled = withStyles(() => ({\n    root: {\n        borderColor: 'transparent',\n        paddingTop: '1rem',\n        paddingBottom: '1rem',\n        fontSize: '14px',\n        color: '#FFFFFF'\n    }\n}))(TableCell);\n\nconst PubSubTest = ({ user }) => {\n    const { streamId } = useParams();\n    const classes = useStyles();\n    const { t } = useTranslation();\n\n    const [connectedToTwitch, setConnectedToTwitch] = useState(false);\n    const [verifyngRedemptions, setVerifyngRedemptions] = useState(false);\n    const [rewardsIds, setRewardsIds] = useState({});\n    const [isQoinsRewardEnabled, setIsQoinsRewardEnabled] = useState(false);\n    const [oldUser, setOldUser] = useState({ twitchAccessToken: '' });\n    const [streamTimestamp, setStreamTimestamp] = useState(0);\n    const [usersThatRedeemed, setUsersThatRedeemed] = useState({});\n    const [buttonFirstText, setButtonFirstText] = useState(t('handleStream.connect'));\n    const [eventIsAlreadyClosed, setEventIsAlreadyClosed] = useState(false);\n    const [connectionStatus, setConnectionStatus] = useState(TWITCH_PUBSUB_UNCONNECTED);\n    let pingTimeout;\n\n    useEffect(() => {\n        async function getTimestamp() {\n            if (streamId) {\n                const timestamp = await getStreamTimestamp(streamId);\n                if (timestamp.exists()) {\n                    setStreamTimestamp(timestamp.val());\n                }\n            }\n        }\n\n        async function checkIfStreamIsAlreadyOpen() {\n            if (user && user.uid && Object.keys(rewardsIds).length < 2) {\n                const rewardOnDatabase = await getStreamCustomReward(user.uid, streamId);\n                if (rewardOnDatabase.exists()){\n                    if (rewardOnDatabase.val().closedStream) {\n                        setEventIsAlreadyClosed(true);\n                    } else {\n                        setButtonFirstText(t('handleStream.reconnect'));\n                    }\n                }\n            }\n        }\n\n        listenCustomRewardRedemptions(streamId, (users) => {\n            if (users.exists()) {\n                let usersToSave = {};\n                users.forEach((user) => {\n                    if (usersToSave[user.val().id]) {\n                        usersToSave[user.val().id].numberOfRedemptions++;\n                    } else {\n                        usersToSave[user.val().id] = user.val();\n                        usersToSave[user.val().id].numberOfRedemptions = 1;\n                    }\n                });\n\n                setUsersThatRedeemed(usersToSave);\n            }\n        });\n\n        if (rewardsAreCreated() && user.twitchAccessToken !== oldUser.twitchAccessToken) {\n            connect(streamId, user.displayName, user.uid, user.twitchAccessToken, user.refreshToken, [`channel-points-channel-v1.${user.id}`], rewardsIds, onPong, handleTwitchSignIn);\n            setOldUser(user);\n        }\n\n        checkIfStreamIsAlreadyOpen();\n        getTimestamp();\n        if (connectedToTwitch) {\n            window.onbeforeunload = () => true;\n        }\n\n        return (() => {\n            window.onbeforeunload = null;\n        });\n    }, [streamId, connectedToTwitch, user, rewardsIds, oldUser, streamTimestamp]);\n\n    const listenForRewards = async () => {\n        const userCredentialsUpdated = await handleTwitchSignIn();\n\n        const rewardOnDatabase = await getStreamCustomReward(user.uid, streamId);\n\n        if (rewardOnDatabase.exists()){\n            if (!rewardOnDatabase.val().closedStream) {\n                let rewards = { expReward: rewardOnDatabase.val().expReward.rewardId, qoinsReward: rewardOnDatabase.val().qoinsReward.rewardId }\n                setRewardsIds(rewards);\n\n                connect(streamId, user.displayName, user.uid, userCredentialsUpdated.access_token, userCredentialsUpdated.refresh_token, [`channel-points-channel-v1.${user.id}`], rewards, onPong, handleTwitchSignIn);\n                setOldUser(user);\n                setConnectedToTwitch(true);\n                alert(t('handleStream.reconnected'));\n            } else {\n                alert(t('handleStream.streamClosed'));\n            }\n        } else {\n            const currentDate = new Date();\n            const streamScheduledDate = new Date(streamTimestamp);\n            if (currentDate.getTime() <= (streamScheduledDate.getTime() + (HOUR_IN_MILISECONDS * 2))) {\n                alert(t('handleStream.connecting'));\n                const rewards = await createReward();\n\n                if (rewards) {\n                    connect(streamId, user.displayName, user.uid, userCredentialsUpdated.access_token, userCredentialsUpdated.refresh_token, [`channel-points-channel-v1.${user.id}`], rewards, onPong, handleTwitchSignIn);\n                    setOldUser(user);\n                    setConnectedToTwitch(true);\n                } else {\n                    alert('Qapla Custom Reward couldn´t been created');\n                }\n            } else {\n                alert(t('handleStream.timeError'));\n            }\n        }\n    }\n\n    const onPong = () => {\n        clearTimeout(pingTimeout);\n        setConnectionStatus(TWITCH_PUBSUB_CONNECTED);\n        setConnectedToTwitch(true);\n        pingTimeout = setTimeout(() => {\n            setConnectionStatus(TWITCH_PUBSUB_CONNECTION_LOST);\n            setConnectedToTwitch(false);\n            connect(streamId, user.displayName, user.uid, user.twitchAccessToken, user.refreshToken, [`channel-points-channel-v1.${user.id}`], rewardsIds, onPong, handleTwitchSignIn);\n        }, 16000);\n    }\n\n    const createReward = async (userCredentials) => {\n        let date = new Date();\n        if (date.getTime() >= streamTimestamp - 900000) {\n            let rewardsIdsObject = {};\n            const expReward = await createCustomReward(user.uid, user.id, userCredentials.access_token, userCredentials.refresh_token, 'XQ Qapla', 500, true, handleTwitchSignIn, streamId);\n            const qoinsReward = await createCustomReward(user.uid, user.id, userCredentials.access_token, userCredentials.refresh_token, 'Qoins Qapla', 500, false, handleTwitchSignIn, streamId, true, 75);\n\n            if (!expReward || !qoinsReward) {\n                return await handleDuplicatedCustomReward();\n            }\n\n            rewardsIdsObject = { expReward: expReward.id, qoinsReward: qoinsReward.id };\n\n            if (Object.keys(rewardsIdsObject).length === 2) {\n                setRewardsIds({ expReward: expReward.id, qoinsReward: qoinsReward.id });\n                await saveStreamerTwitchCustomReward(user.uid, 'expReward', expReward.id, expReward.title, expReward.cost, streamId);\n                await saveStreamerTwitchCustomReward(user.uid, 'qoinsReward', qoinsReward.id, qoinsReward.title, qoinsReward.cost, streamId);\n                alert(t('handleStream.rewardsCreated'));\n            }\n\n            return rewardsIdsObject;\n        } else {\n            alert('La conexion solo puede realizarse cuando mucho 15 minutos antes de la hora en que esta programado el evento');\n        }\n\n        return null;\n    }\n\n    const handleDuplicatedCustomReward = async () => {\n        alert(t('handleStream.streamerHasAnOpenStream'));\n        const activeRewards = await getOpenCustomRewards(user.uid);\n        let rewardsIdsToDelete = {};\n        let streamIdToClose;\n        activeRewards.forEach((activeReward) => {\n            rewardsIdsToDelete.expReward = activeReward.val().expReward.rewardId;\n            rewardsIdsToDelete.qoinsReward = activeReward.val().qoinsReward.rewardId;\n            streamIdToClose = activeReward.key;\n        });\n\n        if (rewardsIdsToDelete.expReward && rewardsIdsToDelete.qoinsReward && streamIdToClose) {\n            const userCredentialsUpdated = await handleTwitchSignIn();\n\n            await finishStream(streamIdToClose, rewardsIdsToDelete);\n\n            return await createReward(userCredentialsUpdated);\n        } else {\n            alert('Las recompensas existentes no han podido ser eliminadas, contacta con soporte técnico.');\n        }\n    }\n\n    const deleteReward = async (rewardIdToDelete, userCredentials) => {\n        const result = await deleteCustomReward(user.uid, user.id, userCredentials.access_token, userCredentials.refresh_token, rewardIdToDelete, handleTwitchSignIn);\n\n        console.log(result);\n\n        if (result === 204) {\n            alert('Recompensa eliminada correctamente');\n        } else if (result === 404 || result === 403) {\n            alert(`No se encontro la recompensa a eliminar, status: ${result}`);\n        } else if (result === 500) {\n            alert('Error de parte de Twitch al tratar de eliminar la recompensa');\n        }\n    }\n\n    const handleTwitchSignIn = async () => {\n        let user = await signInWithTwitch();\n        await updateStreamerProfile(user.firebaseAuthUser.user.uid, user.userData);\n\n        user.access_token = user.userData.twitchAccessToken;\n        user.refresh_token = user.userData.refreshToken;\n        return user;\n    }\n\n    const unlistenForRewards = async () => {\n        if (window.confirm(t('handleStream.closeStreamConfirmation'))) {\n            await closeStream();\n        }\n    }\n\n    const closeStream = async () => {\n        closeConnection();\n\n        finishStream(streamId, rewardsIds);\n    }\n\n    const finishStream = async (streamIdToClose, rewardsIdsToDelete) => {\n        setVerifyngRedemptions(true);\n        const userCredentialsUpdated = await handleTwitchSignIn();\n\n        // Give rewards to Qapla users that were not registered to the event\n        await handleFailedRewardRedemptions(streamIdToClose, rewardsIdsToDelete, userCredentialsUpdated);\n\n        // Remove the custom reward from the ActiveCustomReward node on the database\n        await removeActiveCustomRewardFromList(streamIdToClose);\n\n        const rewardsIdToDeleteArray = Object.keys(rewardsIdsToDelete).map((reward) => rewardsIdsToDelete[reward]);\n\n        // Just then remove the reward. This line can not never be before the handleFailedRewardRedemptions\n        for (let i = 0; i < rewardsIdToDeleteArray.length; i++) {\n            await deleteReward(rewardsIdToDeleteArray[i], userCredentialsUpdated);\n        }\n\n        // Mark as closed the stream on the database\n        await markAsClosedStreamerTwitchCustomReward(user.uid, streamIdToClose);\n\n        setRewardsIds({});\n\n        setVerifyngRedemptions(false);\n        setConnectedToTwitch(false);\n\n        alert(t('handleStream.rewardsSent'));\n    }\n\n    const handleFailedRewardRedemptions = async (streamIdToAssignRewards, rewardsIdsToDelete, userCredentials) => {\n        setStreamInRedemptionsLists(streamId);\n        const expRedemptions = await getAllRewardRedemptions(user.uid, user.id, userCredentials.access_token, userCredentials.refresh_token, rewardsIdsToDelete.expReward, handleTwitchSignIn);\n        let usersPrizes = {};\n        for (let i = 0; i < expRedemptions.length; i++) {\n            const redemption = expRedemptions[i];\n            const qaplaUser = await getUserByTwitchId(redemption.user_id);\n            if (qaplaUser) {\n                const userRedemptionsOnDatabase = await getStreamUserRedemptions(qaplaUser.id, streamIdToAssignRewards);\n                usersPrizes[redemption.user_id] = {\n                    twitchUserName: redemption.user_name,\n                    redemptionId: redemption.id,\n                    rewardId: redemption.reward.id,\n                    status: redemption.status,\n                    timestamp: redemption.redeemed_at,\n                    uid: qaplaUser.id,\n                    qaplaLevel: qaplaUser.qaplaLevel,\n                    userName: qaplaUser.userName,\n                    photoUrl: qaplaUser.photoUrl,\n                    redemptions: userRedemptionsOnDatabase.exists() ? userRedemptionsOnDatabase.val() : null\n                };\n            }\n        }\n\n        addListToStreamRedemptionList(streamId, 'XQReward', expRedemptions);\n\n        let usersPrizeArray = Object.keys(usersPrizes).map((twitchId) => ({ ...usersPrizes[twitchId], twitchId }));\n\n        for (let i = 0; i < usersPrizeArray.length; i++) {\n            const twitchUser = usersPrizeArray[i];\n            let giveXQToUser = true;\n\n            // If the user has no redemptions on our database but is in the list it means it actually has redeemed the reward with Twitch\n            if (twitchUser.redemptions) {\n                // If the user has redemptions on our database but has no redemptions of XQ type set giveXQToUser to true\n                giveXQToUser = !Object.keys(twitchUser.redemptions).some((redemptionId) => twitchUser.redemptions[redemptionId].type === XQ);\n            }\n\n            if (giveXQToUser) {\n                await saveCustomRewardRedemption(twitchUser.uid, twitchUser.photoUrl, twitchUser.twitchId, twitchUser.twitchUserName, streamIdToAssignRewards, XQ, twitchUser.redemptionId, twitchUser.rewardId, twitchUser.status);\n\n                const expToGive = 15;\n                giveStreamExperienceForRewardRedeemed(twitchUser.uid, twitchUser.qaplaLevel, twitchUser.userName, expToGive);\n                addInfoToEventParticipants(streamIdToAssignRewards, twitchUser.uid, 'xqRedeemed', expToGive);\n                saveUserStreamReward(twitchUser.uid, XQ, user.displayName, streamIdToAssignRewards, expToGive);\n\n                const userHasRedeemedQoins = twitchUser.redemptions ? Object.keys(twitchUser.redemptions).some((redemptionId) => twitchUser.redemptions[redemptionId].type === QOINS) : false;\n\n                if (userHasRedeemedQoins) {\n                    let qoinsToGive = 5;\n\n                    addQoinsToUser(twitchUser.uid, qoinsToGive);\n                    addInfoToEventParticipants(streamIdToAssignRewards, twitchUser.uid, 'qoinsRedeemed', qoinsToGive * 2);\n                    saveUserStreamReward(twitchUser.uid, QOINS, user.displayName, streamIdToAssignRewards, qoinsToGive);\n                }\n            }\n        }\n\n        const qoinsRedemptions = await getAllRewardRedemptions(user.uid, user.id, userCredentials.access_token, userCredentials.refresh_token, rewardsIdsToDelete.qoinsReward, handleTwitchSignIn);\n        usersPrizes = {};\n        for (let i = 0; i < qoinsRedemptions.length; i++) {\n            const redemption = qoinsRedemptions[i];\n            const qaplaUser = await getUserByTwitchId(redemption.user_id);\n            if (qaplaUser) {\n                const userRedemptionsOnDatabase = await getStreamUserRedemptions(qaplaUser.id, streamIdToAssignRewards);\n                usersPrizes[redemption.user_id] = {\n                    twitchUserName: redemption.user_name,\n                    redemptionId: redemption.id,\n                    rewardId: redemption.reward.id,\n                    status: redemption.status,\n                    timestamp: redemption.redeemed_at,\n                    uid: qaplaUser.id,\n                    qaplaLevel: qaplaUser.qaplaLevel,\n                    userName: qaplaUser.userName,\n                    photoUrl: qaplaUser.photoUrl,\n                    redemptions: userRedemptionsOnDatabase.exists() ? userRedemptionsOnDatabase.val() : null\n                };\n            }\n        }\n\n        addListToStreamRedemptionList(streamId, 'QoinsReward', qoinsRedemptions);\n\n        usersPrizeArray = Object.keys(usersPrizes).map((twitchId) => ({ ...usersPrizes[twitchId], twitchId }));\n\n        for (let i = 0; i < usersPrizeArray.length; i++) {\n            const twitchUser = usersPrizeArray[i];\n            let giveQoinsToUser = true;\n\n            // If the user has no redemptions on our database but is in the list it means it actually has redeemed the reward with Twitch\n            if (twitchUser.redemptions) {\n                // If the user has redemptions on our database but has no redemptions of QOINS type set giveQoinsToUser to true\n                giveQoinsToUser = !Object.keys(twitchUser.redemptions).some((redemptionId) => twitchUser.redemptions[redemptionId].type === QOINS);\n            }\n\n            if (giveQoinsToUser) {\n                await saveCustomRewardRedemption(twitchUser.uid, twitchUser.photoUrl, twitchUser.twitchId, twitchUser.userName, streamIdToAssignRewards, QOINS, twitchUser.redemptionId, twitchUser.rewardId, twitchUser.status);\n\n                let qoinsToGive = 5;\n\n                const userHasRedeemedExperience = twitchUser.redemptions ? Object.keys(twitchUser.redemptions).some((redemptionId) => twitchUser.redemptions[redemptionId].type === XQ) : false;\n\n                // If the user has redeemed both XQ and Qoins rewards\n                if (userHasRedeemedExperience) {\n                    // Give him 10 qoins instead of 5\n                    qoinsToGive = 10;\n                }\n\n                addQoinsToUser(twitchUser.uid, qoinsToGive);\n                addInfoToEventParticipants(streamIdToAssignRewards, twitchUser.uid, 'qoinsRedeemed', qoinsToGive);\n                saveUserStreamReward(twitchUser.uid, QOINS, user.displayName, streamIdToAssignRewards, qoinsToGive);\n            }\n        }\n    }\n\n    const enableQoinsReward = async () => {\n        const userCredentialsUpdated = await handleTwitchSignIn();\n        if (await enableCustomReward(user.uid, user.id, userCredentialsUpdated.access_token, userCredentialsUpdated.refresh_token, rewardsIds.qoinsReward, handleTwitchSignIn) === 200) {\n            setIsQoinsRewardEnabled(true);\n        }\n    }\n\n    const rewardsAreCreated = () => Object.keys(rewardsIds).length === 2;\n\n    return (\n        <StreamerDashboardContainer user={user}>\n            <Prompt when={connectedToTwitch}\n                message='If you leave now you will lose the connection with Twitch and the rewards will not be sent in real time to the users' />\n            <Grid container>\n                <Grid xs={5} container>\n                    <Grid xs={6}>\n                        <ContainedButton onClick={!connectedToTwitch ? listenForRewards : unlistenForRewards}\n                            disabled={verifyngRedemptions || eventIsAlreadyClosed}\n                            endIcon={verifyngRedemptions ? <CircularProgress style={{ color: '#FFF' }} /> : null}>\n                            {verifyngRedemptions ?\n                                t('handleStream.sendingRewards')\n                            :\n                                !connectedToTwitch ? eventIsAlreadyClosed ? t('handleStream.streamClosed') : buttonFirstText : t('handleStream.endStream')\n                            }\n                        </ContainedButton>\n                        {(connectedToTwitch && !isQoinsRewardEnabled) &&\n                            <ContainedButton onClick={enableQoinsReward} className={classes.secondaryButton}>\n                                {t('handleStream.enableQoinsReward')}\n                            </ContainedButton>\n                        }\n                        {(!eventIsAlreadyClosed && connectionStatus !== TWITCH_PUBSUB_UNCONNECTED) &&\n                            <div style={{ display: 'flex', flexDirection: 'row', justifyContent: 'center', alignItems: 'center', marginTop: 24 }}>\n                                {connectionStatus === TWITCH_PUBSUB_CONNECTED ?\n                                    <ConnectedIcon height={32} width={32} />\n                                    :\n                                    <DisconnectedIcon height={32} width={32} />\n                                }\n                                {connectionStatus === TWITCH_PUBSUB_CONNECTED ?\n                                    <p style={{ color: '#0AFFD2', marginLeft: 8 }}>\n                                        Conectado\n                                    </p>\n                                    :\n                                    <p style={{ color: '#FF0000', marginLeft: 8 }}>\n                                        Error de conexión. Reconectando...\n                                    </p>\n                                }\n                            </div>\n                        }\n                    </Grid>\n                </Grid>\n                {Object.keys(usersThatRedeemed).length > 0 &&\n                    <Grid xs={4}>\n                        <TableContainer className={classes.tableContainer}>\n                            <Table>\n                                <TableHead>\n                                    <TableRow>\n                                        <TableCellStyled align='center' padding='checkbox'>\n                                            <ProfileIcon />\n                                        </TableCellStyled>\n                                        <TableCellStyled className={classes.tableHead}>Twitch Username</TableCellStyled>\n                                        <TableCellStyled className={classes.tableHead}>Nº of Redemptions</TableCellStyled>\n                                    </TableRow>\n                                </TableHead>\n                                <TableBody>\n                                    {Object.keys(usersThatRedeemed).map((uid, index) => (\n                                        <TableRow className={index % 2 === 0 ? classes.tableRow : classes.tableRowOdd}\n                                            key={`Participant-${uid}`}>\n                                            <TableCellStyled align='center' className={classes.firstCell}>\n                                                <Avatar\n                                                    className={classes.avatar}\n                                                    src={usersThatRedeemed[uid].photoUrl} />\n                                            </TableCellStyled>\n                                            <TableCellStyled>\n                                                {usersThatRedeemed[uid].displayName}\n                                            </TableCellStyled>\n                                            <TableCellStyled className={classes.lastCell}>\n                                                {usersThatRedeemed[uid].numberOfRedemptions}\n                                            </TableCellStyled>\n                                        </TableRow>\n                                    ))}\n                                </TableBody>\n                            </Table>\n                        </TableContainer>\n                    </Grid>\n                }\n            </Grid>\n        </StreamerDashboardContainer>\n    );\n}\n\nexport default PubSubTest;\n",["136","137"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/index.js",[],["138","139"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamersSignin/StreamersSignin.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/InviteCode/InviteCode.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EditStreamerEvent/EditStreamerEvent.jsx",[],["140","141"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/database.js",["142","143"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LanguageSelect/LanguageSelect.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/Router.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSideBar/StreamerSideBar.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/PlanPicker/PlanPicker.jsx",["144"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerOnBoarding/StreamerOnBoarding.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/twitch.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerSelect/StreamerSelect.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaTabs/QaplaTab.jsx",["145"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerTextInput/StreamerTextInput.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LanguageHandler/LanguageHandler.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerProfile/StreamerProfile.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/functions.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/QaplaTabs/QaplaTabs.jsx",["146"],"import React from 'react';\nimport { withStyles, Tabs } from '@material-ui/core';\n\nconst QaplaTabs = withStyles({\n    root: {\n        borderBottom: 'transparent',\n    },\n    indicator: {\n        backgroundColor: '#0AFFD2',\n    },\n})(Tabs);\n\nexport default (props) => <QaplaTabs {...props} />;","/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/BackButton/BackButton.jsx",[],["147","148"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/EventSent/EventSent.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/firebase.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/NewStreamDetailsDialog/NewStreamDetailsDialog.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/services/discord.js",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/Settings/Settings.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/ContainedButton/ContainedButton.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/NewStream/NewStream.jsx",["149"],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamerDashboardContainer/StreamerDashboardContainer.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/LiveDonations/LiveDonations.jsx",[],"/Users/diego/Documents/react/QaplaStreamersDashboard/src/components/StreamCard/StreamCard.jsx",[],{"ruleId":"150","replacedBy":"151"},{"ruleId":"152","replacedBy":"153"},{"ruleId":"154","severity":1,"message":"155","line":162,"column":8,"nodeType":"156","endLine":162,"endColumn":81,"suggestions":"157"},{"ruleId":"150","replacedBy":"158"},{"ruleId":"152","replacedBy":"159"},{"ruleId":"150","replacedBy":"160"},{"ruleId":"152","replacedBy":"161"},{"ruleId":"150","replacedBy":"162"},{"ruleId":"152","replacedBy":"163"},{"ruleId":"164","severity":2,"message":"165","line":535,"column":33,"nodeType":"166","messageId":"167","endLine":535,"endColumn":53},{"ruleId":"168","severity":1,"message":"169","line":538,"column":53,"nodeType":"170","messageId":"171","endLine":538,"endColumn":55},{"ruleId":"154","severity":1,"message":"172","line":54,"column":8,"nodeType":"156","endLine":54,"endColumn":48,"suggestions":"173"},{"ruleId":"174","severity":1,"message":"175","line":26,"column":1,"nodeType":"176","endLine":26,"endColumn":51},{"ruleId":"174","severity":1,"message":"175","line":13,"column":1,"nodeType":"176","endLine":13,"endColumn":52},{"ruleId":"150","replacedBy":"177"},{"ruleId":"152","replacedBy":"178"},{"ruleId":"154","severity":1,"message":"179","line":111,"column":8,"nodeType":"156","endLine":111,"endColumn":14,"suggestions":"180"},"no-native-reassign",["181"],"no-negated-in-lhs",["182"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'onPong', 'rewardsAreCreated', and 't'. Either include them or remove the dependency array.","ArrayExpression",["183"],["181"],["182"],["181"],["182"],["181"],["182"],"no-undef","'specialEventsDataRef' is not defined.","Identifier","undef","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","React Hook useEffect has an unnecessary dependency: 'userIsTryingToSubscribe'. Either exclude it or remove the dependency array. Outer scope values like 'userIsTryingToSubscribe' aren't valid dependencies because mutating them doesn't re-render the component.",["184"],"import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration",["181"],["182"],"React Hook useEffect has a missing dependency: 'history'. Either include it or remove the dependency array.",["185"],"no-global-assign","no-unsafe-negation",{"desc":"186","fix":"187"},{"desc":"188","fix":"189"},{"desc":"190","fix":"191"},"Update the dependencies array to be: [streamId, connectedToTwitch, user, rewardsIds, oldUser, streamTimestamp, rewardsAreCreated, t, onPong]",{"range":"192","text":"193"},"Update the dependencies array to be: [user, history]",{"range":"194","text":"195"},"Update the dependencies array to be: [history, user]",{"range":"196","text":"197"},[5547,5620],"[streamId, connectedToTwitch, user, rewardsIds, oldUser, streamTimestamp, rewardsAreCreated, t, onPong]",[2707,2747],"[user, history]",[3687,3693],"[history, user]"]